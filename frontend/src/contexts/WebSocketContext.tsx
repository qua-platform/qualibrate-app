/**
 * @fileoverview WebSocket state management for real-time quantum calibration updates.
 *
 * This context provides WebSocket connections to two backend endpoints for real-time
 * communication during calibration workflows:
 * 1. `/execution/ws/run_status` - Real-time node/graph execution status updates
 * 2. `/execution/ws/workflow_execution_history` - Historical execution records for timeline view
 *
 * **Architecture**:
 * - Uses singleton WebSocketService instances per connection (stored in useRef)
 * - Auto-reconnects once per second until the server becomes available again
 * - Supports pub/sub pattern with subscribe/unsubscribe for multiple consumers
 * - Updates pushed to state every ~500ms during active calibration runs
 *
 * **Provider Hierarchy**:
 * Must wrap all components that need real-time updates. Currently wraps entire app
 * at index.tsx level (inside GlobalThemeContextProvider), providing updates to:
 * - NodesContext: Consumes runStatus for node execution state synchronization
 * - GraphContext: Consumes runStatus for graph workflow visualization
 * - SnapshotsContext: May consume history for timeline updates
 *
 * **Connection Lifecycle**:
 * - Connects on mount (via useEffect initialization)
 * - Disconnects on unmount (cleanup function)
 * - Reconnection handled automatically by WebSocketService with continuous 1s retries
 *
 * **Critical Integration Point**:
 * NodesContext.tsx subscribes to runStatus changes via useEffect,
 * triggering node execution state updates when runStatus.runnable_type === "node".
 *
 * **IMPROVEMENT NEEDED: Error Handling**:
 * - WebSocket errors only log to console (limited user feedback beyond the dialog)
 * - Connection failures during reconnection rely solely on automatic retry (no manual override)
 * - No circuit breaker pattern for persistent connection failures
 * - Consider adding connection status indicator and error boundaries
 *
 * @see WebSocketService for low-level WebSocket management implementation
 * @see NodesContext for primary consumer of runStatus updates (lines 265-269)
 * @see GraphContext for graph workflow visualization integration
 */

import React, {createContext, PropsWithChildren, useCallback, useContext, useEffect, useRef, useState} from "react";
import WebSocketService from "../services/WebSocketService";
import {WS_EXECUTION_HISTORY, WS_GET_STATUS} from "../services/webSocketRoutes";
import {ErrorObject} from "../modules/common/Error/ErrorStatusWrapper";
import {Measurement} from "../modules/GraphLibrary/components/GraphStatus/context/GraphStatusContext";
import {BasicDialog} from "../common/ui-components/common/BasicDialog/BasicDialog";
import {useProjectContext} from "../modules/Project/context/ProjectContext";

/**
 * Results of a completed calibration node execution.
 *
 * Contains all data generated by a quantum calibration run including parameters used,
 * measured outcomes, errors encountered, and which quantum targets were successfully calibrated.
 *
 * @property parameters - Input parameters used for this calibration run
 * @property outcomes - Measured results and fitted parameters from calibration
 * @property error - Error information if calibration failed, null if successful
 * @property initial_targets - Quantum targets (qubits/resonators) attempted for calibration
 * @property successful_targets - Subset of initial_targets that completed successfully
 *
 * @remarks
 * This data is included in NodeExecution.run_results and becomes available when
 * NodeExecution.status transitions to "finished" or "failed".
 *
 * @see NodeExecution for the complete execution state container
 */
export interface RunResults {
  parameters: Record<string, unknown>;
  outcomes: Record<string, unknown>;
  error: ErrorObject | null;
  initial_targets: unknown[];
  successful_targets: unknown[];
}

/**
 * Execution state for a single quantum calibration node.
 *
 * Updated in real-time via WebSocket during calibration runs. This interface represents
 * the live execution state as reported by the backend, with updates pushed approximately
 * every 500ms during active calibration.
 *
 * All time-related fields use seconds as units (run_duration, time_remaining).
 *
 * @property current_action - Current operation being performed (e.g., "measuring", "analyzing", "fitting data")
 * @property description - Human-readable description of the node's calibration purpose
 * @property id - Unique execution ID (increments with each run, used for snapshot retrieval)
 * @property name - Node class name (e.g., "resonator_spectroscopy", "qubit_spectroscopy")
 * @property parameters - User-provided execution parameters for this calibration run
 * @property percentage_complete - Progress from 0-100 indicating completion percentage
 * @property run_duration - Elapsed time in seconds since calibration started
 * @property run_end - ISO timestamp when execution completed (string format: "YYYY-MM-DDTHH:mm:ss")
 * @property run_start - ISO timestamp when execution began (string format: "YYYY-MM-DDTHH:mm:ss")
 * @property status - Execution state: "pending" | "running" | "finished" | "failed"
 * @property time_remaining - Estimated seconds until completion (0 if unknown/not estimated)
 * @property run_results - Final outcomes and state updates after node completion (available when status="finished")
 *
 * @remarks
 * **State Transition Flow**:
 * pending → running → finished/failed (transitions are irreversible)
 *
 * **WebSocket Update Frequency**:
 * The WebSocket connection pushes updates to this structure every ~500ms during execution.
 * NodesContext.tsx consumes these updates via useEffect on runStatus changes.
 *
 * **Data Synchronization**:
 * When status transitions to "finished", NodesContext fetches the complete results
 * via SnapshotsApi.fetchSnapshotResult(id) to retrieve full calibration data including
 * figures, fitted parameters, and quantum state updates.
 *
 * @see RunStatusType for the complete WebSocket message format
 * @see NodesContext for state synchronization consumer
 * @see RunResults for the structure of run_results after completion
 */
export interface NodeExecution {
  current_action: string | null;
  description: string | null;
  id: number;
  name: string;
  parameters: Record<string, unknown>;
  percentage_complete: number;
  run_duration: number;
  run_end: string;
  run_start: string;
  status: "pending" | "running" | "finished" | "failed" | string;
  time_remaining: number;
  run_results: RunResults;
}

/**
 * Execution state for a calibration graph workflow.
 *
 * A graph represents a directed acyclic graph (DAG) of multiple calibration nodes
 * executed in sequence or parallel according to their dependencies. This interface
 * tracks progress across the entire multi-node workflow.
 *
 * @property name - Unique identifier for the graph workflow
 * @property description - Human-readable explanation of the workflow's calibration goal
 * @property finished_nodes - Count of nodes that have completed execution (finished or failed)
 * @property total_nodes - Total number of nodes in the workflow graph
 * @property run_start - ISO timestamp or Date when graph execution began
 * @property run_end - Timestamp when execution completed (number format - INVESTIGATE: inconsistent with run_start type)
 * @property percentage_complete - Overall graph progress from 0-100
 * @property run_duration - Total elapsed time in seconds
 * @property time_remaining - Estimated seconds until completion (0 if unknown)
 * @property error - Error information if graph execution failed
 * @property status - Execution state: "pending" | "running" | "finished" | "failed"
 *
 * @remarks
 * **FRAGILE: Type Inconsistency**:
 * run_start is typed as `string | Date` while run_end is `number`. This inconsistency
 * suggests potential runtime errors when comparing or formatting timestamps. Backend
 * may be sending different types at different stages. Consider standardizing to ISO strings.
 *
 * **Graph Execution Model**:
 * Graph execution orchestrates multiple NodeExecution instances. When runnable_type="graph",
 * this structure tracks overall workflow progress while individual node updates are still
 * pushed via NodeExecution messages.
 *
 * @see RunStatusType for the discriminated union containing this type
 * @see NodeExecution for individual node execution within the graph
 */
export type GraphItem = {
  name: string;
  description: string;
  finished_nodes: number;
  total_nodes: number;
  run_start: string | Date;
  run_end: number;
  percentage_complete: number;
  run_duration: number;
  time_remaining: number;
  error?: ErrorObject;
  status: "pending" | "running" | "finished" | "failed";
};

/**
 * Real-time calibration execution status message.
 *
 * Discriminated union type that represents either a single node execution or a
 * multi-node graph workflow execution. Pushed via WebSocket every ~500ms during
 * active calibration runs.
 *
 * @property is_running - True if any calibration is currently executing, false if idle
 * @property graph - Graph workflow execution state (null if runnable_type="node")
 * @property node - Single node execution state (null if runnable_type="graph")
 * @property runnable_type - Discriminator: "node" for single node, "graph" for workflow
 *
 * @remarks
 * **Discriminated Union Pattern**:
 * Use runnable_type to determine which field (graph or node) contains valid data:
 * - When runnable_type="node": node is populated, graph is null
 * - When runnable_type="graph": graph is populated, node may still contain current node info
 *
 * @see NodeExecution for node-level execution details
 * @see GraphItem for graph-level execution details
 * @see NodesContext for primary consumer implementation
 */
export type RunStatusType = {
  is_running: boolean;
  graph: GraphItem | null;
  node: NodeExecution | null;
  runnable_type: "node" | "graph";
};

/**
 * Historical execution records for timeline visualization.
 *
 * Contains an array of past calibration measurements for displaying execution
 * history, trends, and comparisons in the timeline view.
 *
 * @property items - Array of historical measurement records
 *
 * @remarks
 * Pushed via `/execution/ws/workflow_execution_history` WebSocket endpoint.
 * Used by timeline components to display calibration history and trends.
 *
 * @see Measurement from GraphStatusContext for the item structure
 */
export type HistoryType = {
  items: Measurement[];
};

/**
 * WebSocket context value interface providing real-time calibration data and operations.
 *
 * Provides access to two WebSocket streams (runStatus and history) along with
 * methods for sending data and subscribing to updates via pub/sub pattern.
 *
 * @property runStatus - Current calibration execution status (null if no active run)
 * @property history - Historical execution records (null if not yet received)
 * @property sendRunStatus - Send message to run status WebSocket (rarely used from frontend)
 * @property sendHistory - Send message to history WebSocket (rarely used from frontend)
 * @property subscribeToRunStatus - Register callback for run status updates, returns unsubscribe function
 * @property subscribeToHistory - Register callback for history updates, returns unsubscribe function
 *
 * @see useWebSocketData for the hook to access this context
 * @see WebSocketProvider for the provider component
 */
type WebSocketData = {
  runStatus: RunStatusType | null;
  history: HistoryType | null;
  sendRunStatus: (data: RunStatusType) => void;
  sendHistory: (data: HistoryType) => void;
  subscribeToRunStatus: (cb: (data: RunStatusType) => void) => () => void;
  subscribeToHistory: (cb: (data: HistoryType) => void) => () => void;
};

/**
 * React context for WebSocket real-time calibration data.
 *
 * Initialized with null values for runStatus and history, and no-op functions
 * for all operations. Actual implementations provided by WebSocketProvider.
 */
const WebSocketContext = createContext<WebSocketData>({
  runStatus: null,
  history: null,
  sendRunStatus: () => {},
  sendHistory: () => {},
  subscribeToRunStatus: () => () => {},
  subscribeToHistory: () => () => {},
});

/**
 * Custom hook to access WebSocket data and operations.
 *
 * Provides access to real-time calibration execution status and historical data
 * via WebSocket connections, along with methods for pub/sub pattern subscriptions.
 *
 * @returns {WebSocketData} Object containing:
 *   - runStatus: Latest execution status (null if no active run)
 *   - history: Historical execution records (null if not yet received)
 *   - sendRunStatus: Send message to status WebSocket
 *   - sendHistory: Send message to history WebSocket
 *   - subscribeToRunStatus: Register callback for status updates, returns unsubscribe function
 *   - subscribeToHistory: Register callback for history updates, returns unsubscribe function
 *
 * @throws Implicitly throws if used outside WebSocketProvider (context will have default no-op values)
 *
 * @see WebSocketProvider for the provider component setup
 * @see NodesContext for primary consumer of runStatus
 */
export const useWebSocketData = () => useContext(WebSocketContext);

/**
 * Provider component for WebSocket real-time calibration data.
 *
 * Establishes and manages two WebSocket connections for real-time updates during
 * quantum calibration workflows. Handles automatic reconnection, state management,
 * and pub/sub pattern for multiple subscribers.
 *
 * **Setup Instructions**:
 * Must be placed high in the component tree (currently in index.tsx inside
 * GlobalThemeContextProvider) to ensure all child contexts and components can
 * access real-time data.
 *
 * **WebSocket Connections**:
 * - Run Status: `${protocol}://${host}/execution/ws/run_status`
 * - Execution History: `${protocol}://${host}/execution/ws/workflow_execution_history`
 *
 * **Environment Configuration**:
 * Protocol and host determined by:
 * 1. Protocol: Auto-detected from window.location (http→ws, https→wss)
 * 2. Host: process.env.WS_BASE_URL (if set) or window.location.host + pathname
 *
 * **Lifecycle Management**:
 * - Connections established on component mount (useEffect with empty deps)
 * - Both connections use same WebSocketService with continuous 1s retry cadence
 * - Disconnects gracefully on component unmount via cleanup function
 * - Reconnection handled automatically by WebSocketService (linear backoff, 1s delay)
 *
 * @param props.children - React children to receive WebSocket context
 *
 * @example
 * ```typescript
 * // In index.tsx
 * <GlobalThemeContextProvider>
 *   <WebSocketProvider>
 *     <ApiContextProvider>
 *       <NodesContextProvider>
 *         <App />
 *       </NodesContextProvider>
 *     </ApiContextProvider>
 *   </WebSocketProvider>
 * </GlobalThemeContextProvider>
 * ```
 *
 * @remarks
 * **IMPROVEMENT NEEDED: Error Recovery**:
 * After 5 failed reconnection attempts, the WebSocket service stops trying and
 * connections remain closed indefinitely. Users must refresh the page to restore
 * real-time updates. Consider:
 * - Exponential backoff instead of linear backoff
 * - Unlimited reconnection attempts with longer delays
 * - User-facing "reconnect" button when connection lost
 * - React Error Boundary to catch and report connection failures
 *
 * **Performance Note**:
 * WebSocketService instances are stored in useRef to prevent recreation on re-renders.
 * State updates (setRunStatus, setHistory) trigger re-renders of all consumers,
 * so consider memoization in child components if performance issues arise.
 *
 * @see WebSocketService for low-level connection management (services/WebSocketService.ts)
 * @see useWebSocketData for the hook to consume this context
 * @see WS_GET_STATUS and WS_EXECUTION_HISTORY for WebSocket route constants
 */
export const WebSocketProvider: React.FC<PropsWithChildren> = ({ children }) => {
  // Determine WebSocket protocol based on current page protocol (http→ws, https→wss)
  const protocol = window.location.protocol === "http:" ? "ws" : "wss";
  const location = process.env.WS_BASE_URL || `${window.location.host}${window.location.pathname}`;
  const host = process.env.WS_BASE_URL || location;
  // Use useRef to persist WebSocketService instances across re-renders
  // This prevents reconnection on every component update
  const runStatusWS = useRef<WebSocketService<RunStatusType> | null>(null);
  const historyWS = useRef<WebSocketService<HistoryType> | null>(null);

  // State for current WebSocket data, updated by WebSocketService callbacks
  const [runStatus, setRunStatus] = useState<RunStatusType | null>(null);
  const [history, setHistory] = useState<HistoryType | null>(null);
  const [showConnectionErrorDialog, setShowConnectionErrorDialog] = useState<boolean>(false);
  const [connectionLostAt, setConnectionLostAt] = useState<number | null>(null);
  const [connectionLostSeconds, setConnectionLostSeconds] = useState<number>(0);
  const connectionLostAtRef = useRef<number | null>(null);
  const { refreshShouldGoToProjectPage } = useProjectContext();

  const handleShowConnectionErrorDialog = useCallback(() => {
    if (localStorage.getItem("backandWorking") !== "true") {
      return;
    }

    if (connectionLostAtRef.current === null) {
      const now = Date.now();
      connectionLostAtRef.current = now;
      setConnectionLostAt(now);
      setConnectionLostSeconds(0);
    }
    setShowConnectionErrorDialog(true);
    localStorage.setItem("backandWorking", "false");
  }, []);

  const handleHideConnectionErrorDialog = useCallback(() => {
    setShowConnectionErrorDialog((isVisible) => {
      if (!isVisible) {
        return isVisible;
      }
      localStorage.setItem("backandWorking", "true");
      connectionLostAtRef.current = null;
      setConnectionLostAt(null);
      setConnectionLostSeconds(0);
      void refreshShouldGoToProjectPage();
      return false;
    });
  }, [refreshShouldGoToProjectPage]);

  useEffect(() => {
    if (!showConnectionErrorDialog || connectionLostAt === null) {
      return;
    }
    setConnectionLostSeconds(Math.floor((Date.now() - connectionLostAt) / 1000));
    const intervalId = window.setInterval(() => {
      setConnectionLostSeconds(Math.floor((Date.now() - connectionLostAt) / 1000));
    }, 1000);

    return () => {
      clearInterval(intervalId);
    };
  }, [showConnectionErrorDialog, connectionLostAt]);

  const formatElapsed = (seconds: number) => {
    const minutes = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return minutes > 0 ? `${minutes}m ${secs.toString().padStart(2, "0")}s` : `${secs}s`;
  };

  // Establish WebSocket connections on mount, disconnect on unmount
  // Empty dependency array [] ensures this runs once per component lifecycle
  useEffect(() => {
    // Construct full WebSocket URLs from protocol, host, and route constants
    const runStatusUrl = `${protocol}://${host}${WS_GET_STATUS}`;
    const historyUrl = `${protocol}://${host}${WS_EXECUTION_HISTORY}`;

    runStatusWS.current = new WebSocketService<RunStatusType>(
      runStatusUrl,
      setRunStatus,
      handleHideConnectionErrorDialog,
      handleShowConnectionErrorDialog
    );
    historyWS.current = new WebSocketService<HistoryType>(
      historyUrl,
      setHistory,
      handleHideConnectionErrorDialog,
      handleShowConnectionErrorDialog
    );

    // Initiate connections with continuous 1-second retry cadence
    if (runStatusWS.current && !runStatusWS.current.isConnected()) {
      runStatusWS.current.connect();
    }
    if (historyWS.current && !historyWS.current.isConnected()) {
      historyWS.current.connect();
    }

    // Cleanup function: disconnect WebSockets when component unmounts
    // Prevents memory leaks and dangling connections
    return () => {
      if (runStatusWS.current && runStatusWS.current.isConnected()) {
        runStatusWS.current.disconnect();
      }
      if (historyWS.current && historyWS.current.isConnected()) {
        historyWS.current.disconnect();
      }
    };
  }, []); // Empty deps: run once on mount, cleanup on unmount

  // Message sending functions (Don't seem to be used in this application - WebSockets are used receive-only)
  const sendRunStatus = (data: RunStatusType) => runStatusWS.current?.send(data);
  const sendHistory = (data: HistoryType) => historyWS.current?.send(data);

  // Pub/sub subscription functions for advanced use cases
  // Most consumers just read runStatus/history from context without subscribing
  // Now returns unsubscribe function for convenient cleanup
  const subscribeToRunStatus = (cb: (data: RunStatusType) => void) => {
    return runStatusWS.current?.subscribe(cb) ?? (() => {});
  };

  const subscribeToHistory = (cb: (data: HistoryType) => void) => {
    return historyWS.current?.subscribe(cb) ?? (() => {});
  };

  return (
    <WebSocketContext.Provider
      value={{
        runStatus,
        history,
        sendRunStatus,
        sendHistory,
        subscribeToRunStatus,
        subscribeToHistory,
      }}
    >
      {showConnectionErrorDialog && (
        <BasicDialog
          open={showConnectionErrorDialog}
          title={"Connection lost"}
          description={
            <>
              Connection with the server has been lost.
              <br />
              Retrying for {formatElapsed(connectionLostSeconds)}...
            </>
          }
        />
      )}
      {children}
    </WebSocketContext.Provider>
  );
};
